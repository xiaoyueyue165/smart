var h2m = require('h2m');
var str = `<article class="post detail">
<div class="meta">
    <div class="date">12月15, 2017</div>
    <div class="comment">
        <a href="#comments">0 comments</a>
    </div>
</div>
<h1 class="title">【译】JavaScript：核心 - 第二版</h1>
<div class="entry-content">
    <div class="toc"><ul>
<li><a href="#toc-b14">对象</a></li>
<li><a href="#toc-7c2">原型</a></li>
<li><a href="#toc-fad">类</a></li>
<li><a href="#toc-22a">执行上下文</a></li>
<li><a href="#toc-fa4">环境</a></li>
<li><a href="#toc-0ed">闭包</a></li>
<li><a href="#this">This</a></li>
<li><a href="#toc-aa6">域</a></li>
<li><a href="#toc-116">作业</a></li>
<li><a href="#toc-fc9">代理</a></li>
</ul>
</div><blockquote>
<p>原文地址：<a href="http://dmitrysoshnikov.com/ecmascript/javascript-the-core-2nd-edition/">http://dmitrysoshnikov.com/ecmascript/javascript-the-core-2nd-edition/</a></p>
<p>译者注：Dmitry Soshnikov是Facebook软件工程师，ECMAScript理论家。他编写的<a href="http://dmitrysoshnikov.com">《ECMAScript in detail》</a>系列文章是对ECMAScript规范最优秀的解析，已经被翻译成多国语言（包括中文）。</p>
</blockquote>
<hr>
<p>这是<a href="http://dmitrysoshnikov.com/ecmascript/javascript-the-core/">JavaScript：核心</a>概述讲稿的<em>第二版</em>，致力于ECMAScript编程语言及其运行时系统的核心组件。</p>
<p><strong>目标人群</strong>：有经验的程序员、专家。</p>
<!--toc-->
<p>本文的<a href="http://dmitrysoshnikov.com/ecmascript/javascript-the-core/">第一版</a>涵盖了JS语言的通用方面，主要讲解了旧式ES3规范中的概念，并参考了在ES5和ES6（即ES2015）中的一些变化。</p>
<p>从ES2015开始，规范修改了一些核心组件的描述和结构，引入了新的模型等等。所以在这个版本中，我们会关注较新的概念以及更新了的术语，但是依然保留在规范各个版本中保持一致的最基本的JS结构。</p>
<p>本文涵盖了ES2017+运行时系统。</p>
<blockquote>
<p><strong>注：</strong><a href="https://tc39.github.io/ecma262/">ECMAScript规范</a>的最新版本可以在TC-39网站上找到。</p>
</blockquote>
<p>我们从讨论ECMAScript最基础的概念<em>对象</em>开始。</p>
<!--more-->
<h2><a id="toc-b14" class="anchor" href="#toc-b14"></a>对象</h2>
<p>ECMAScript是一门<em>面向对象</em>的编程语言，它<em>基于原型</em>，以<em>对象</em>作为其核心概念。</p>
<p><strong>定义. 1: 对象:</strong> <em>对象</em>是<em>属性的集合</em>，并且有<em>一个原型对象</em>。原型要么是一个对象，要么是<code>null</code>值。</p>
<p>我们来看一个简单的对象示例。一个对象的原型是被内部的<code>[[Prototype]]</code>属性引用，通过<code>__proto__</code>属性暴露给用户级代码。</p>
<p>对于如下代码：</p>
<pre><code class="hljs lang-dts firekylin-code"><ul><li><span class="line-num" data-line="1"></span>let point = {</li><li><span class="line-num" data-line="2"></span><span class="hljs-symbol">    x:</span> <span class="hljs-number">10</span>,</li><li><span class="line-num" data-line="3"></span><span class="hljs-symbol">    y:</span> <span class="hljs-number">20</span>,</li><li><span class="line-num" data-line="4"></span>};</li></ul><b class="name">dts</b></code></pre><p>其结构中带有两个<em>显式的自有属性</em>和一个<em>隐式</em>的<code>__proto__</code>属性，<code>__proto__</code>属性是对<code>point</code>的原型的引用：</p>
<p><img class="" src="http://www.xiaojichao.com/static/upload/20171215/VUPIxH1_TRwvk9IJAljc.png" alt="alt"><noscript><img src="http://www.xiaojichao.com/static/upload/20171215/VUPIxH1_TRwvk9IJAljc.png" alt="alt"></noscript></p>
<p>图 1. 带有原型的基本对象</p>
<blockquote>
<p><strong>注：</strong>对象也可以存储<em>symbol</em>。有关symbol的更多信息，请参考<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol">这份文档</a>。</p>
</blockquote>
<p>原型对象用于以<em>动态调度</em>机制实现<em>继承</em>。下面我们研究一下<em>原型链</em>的概念，详细看看这种机制是怎么回事。</p>
<h2><a id="toc-7c2" class="anchor" href="#toc-7c2"></a>原型</h2>
<p>每个对象在创建时都会得到其<em>原型</em>（prototype）。如果原型没有<em>显式</em>设置，对象会以<em>默认原型</em>作为其<em>继承对象</em>。</p>
<p><strong>定义 2. 原型：*</strong>原型<em>是用于实现</em>基于原型的继承*的委托对象。</p>
<p>原型可以通过用<code>__proto__</code>属性或者<code>Object.create()</code>方法<em>显式</em>设置：</p>
<pre><code class="hljs lang-qml firekylin-code"><ul><li><span class="line-num" data-line="1"></span><span class="hljs-comment">// 基对象</span></li><li><span class="line-num" data-line="2"></span><span class="hljs-keyword">let</span> <span class="hljs-built_in">point</span> = {</li><li><span class="line-num" data-line="3"></span>    <span class="hljs-attribute">x</span>: <span class="hljs-number">10</span>,</li><li><span class="line-num" data-line="4"></span>    <span class="hljs-attribute">y</span>: <span class="hljs-number">20</span>,</li><li><span class="line-num" data-line="5"></span>};</li><li><span class="line-num" data-line="6"></span></li><li><span class="line-num" data-line="7"></span><span class="hljs-comment">// 继承自point对象</span></li><li><span class="line-num" data-line="8"></span><span class="hljs-keyword">let</span> point3D = {</li><li><span class="line-num" data-line="9"></span>    <span class="hljs-attribute">z</span>: <span class="hljs-number">30</span>,</li><li><span class="line-num" data-line="10"></span>    <span class="hljs-attribute">__proto__</span>: <span class="hljs-built_in">point</span>,</li><li><span class="line-num" data-line="11"></span>};</li><li><span class="line-num" data-line="12"></span></li><li><span class="line-num" data-line="13"></span><span class="hljs-built_in">console</span>.log(</li><li><span class="line-num" data-line="14"></span>    point3D.x,  <span class="hljs-comment">// 10, 继承来的</span></li><li><span class="line-num" data-line="15"></span>    point3D.y,  <span class="hljs-comment">// 20, 继承来的</span></li><li><span class="line-num" data-line="16"></span>    point3D.z   <span class="hljs-comment">// 30, 自有的</span></li><li><span class="line-num" data-line="17"></span>);</li></ul><b class="name">qml</b></code></pre><blockquote>
<p><strong>注：</strong>默认情况下，对象以<code>Object.prototype</code>作为其继承对象。</p>
</blockquote>
<p>所有对象都可以作为另一个对象的原型，而且原型本身也可以有自己的原型。如果一个原型有一个对其原型的非空引用，依此类推，就称为<em>原型链</em>。</p>
<p><strong>定义 3：原型链：</strong>原型链是用于实现<em>继承</em>和<em>共享属性</em>的<em>有限</em>对象链。</p>
<p><img class="" src="http://www.xiaojichao.com/static/upload/20171215/0z56lBx7PJ4XFKnKY6io.png" alt="alt"><noscript><img src="http://www.xiaojichao.com/static/upload/20171215/0z56lBx7PJ4XFKnKY6io.png" alt="alt"></noscript></p>
<p>图 2. 原型链</p>
<p>规则很简单：如果一个属性在对象本身中找不到，就试图在原型中<em>解析</em>；如果还找不到，就到原型的原型中找，等等 - 直到找完整个原型链。</p>
<p>从技术上讲，这种机制被称为<em>动态调度</em>（dynamic dispatch）或者<em>委托</em>。</p>
<p><strong>定义 4：委托（Delegation）：</strong>一种用于在继承链中解析一个属性的机制。这个过程发生在运行时，因此也称为<strong>动态调度</strong>（dynamic dispath）。</p>
<blockquote>
<p><strong>注：*</strong>静态调度<em>是在</em>编译时<em>解析引用，而</em>动态调度<em>是在</em>运行时*解析引用。</p>
</blockquote>
<p>并且，如果一个属性最终在原型链中找不到，就返回<code>undefined</code>值：</p>
<pre><code class="hljs lang-zephir firekylin-code"><ul><li><span class="line-num" data-line="1"></span><span class="hljs-comment">// 一个"空"对象</span></li><li><span class="line-num" data-line="2"></span><span class="hljs-keyword">let</span> <span class="hljs-keyword">empty</span> = {};</li><li><span class="line-num" data-line="3"></span></li><li><span class="line-num" data-line="4"></span>console.log(</li><li><span class="line-num" data-line="5"></span></li><li><span class="line-num" data-line="6"></span>  <span class="hljs-comment">// 来自默认运行的函数</span></li><li><span class="line-num" data-line="7"></span>  <span class="hljs-keyword">empty</span>.toString,</li><li><span class="line-num" data-line="8"></span></li><li><span class="line-num" data-line="9"></span>  <span class="hljs-comment">// undefined</span></li><li><span class="line-num" data-line="10"></span>  <span class="hljs-keyword">empty</span>.x, </li><li><span class="line-num" data-line="11"></span>);</li></ul><b class="name">zephir</b></code></pre><p>正如我们所见，默认对象实际上<em>永远不会是空的</em> - 它总会从<code>Object.prototype</code>继承<em>一些东西</em>。如果要创建一个<em>无原型的词典</em>，我们必须显式将其原型设置为<code>null</code>：</p>
<pre><code class="hljs lang-gauss firekylin-code"><ul><li><span class="line-num" data-line="1"></span><span class="hljs-comment">// 不继承任何东西。</span></li><li><span class="line-num" data-line="2"></span><span class="hljs-keyword">let</span> dict = Object.<span class="hljs-keyword">create</span>(<span class="hljs-built_in">null</span>);</li><li><span class="line-num" data-line="3"></span></li><li><span class="line-num" data-line="4"></span>console.<span class="hljs-built_in">log</span>(dict.toString); <span class="hljs-comment">// undefined</span></li></ul><b class="name">gauss</b></code></pre><p><em>动态调度</em>机制允许继承链的<em>完全可变性</em>，提供改变委托对象的能力：</p>
<pre><code class="hljs lang-javascript firekylin-code"><ul><li><span class="line-num" data-line="1"></span><span class="hljs-keyword">let</span> protoA = {<span class="hljs-attr">x</span>: <span class="hljs-number">10</span>};</li><li><span class="line-num" data-line="2"></span><span class="hljs-keyword">let</span> protoB = {<span class="hljs-attr">x</span>: <span class="hljs-number">20</span>};</li><li><span class="line-num" data-line="3"></span></li><li><span class="line-num" data-line="4"></span><span class="hljs-comment">// 与`let objectC = {__proto__: protoA};`相同:</span></li><li><span class="line-num" data-line="5"></span><span class="hljs-keyword">let</span> objectC = <span class="hljs-built_in">Object</span>.create(protoA);</li><li><span class="line-num" data-line="6"></span><span class="hljs-built_in">console</span>.log(objectC.x); <span class="hljs-comment">// 10</span></li><li><span class="line-num" data-line="7"></span></li><li><span class="line-num" data-line="8"></span><span class="hljs-comment">// 改变委托：</span></li><li><span class="line-num" data-line="9"></span><span class="hljs-built_in">Object</span>.setPrototypeOf(objectC, protoB);</li><li><span class="line-num" data-line="10"></span><span class="hljs-built_in">console</span>.log(objectC.x); <span class="hljs-comment">// 20</span></li></ul><b class="name">javascript</b></code></pre><blockquote>
<p><strong>注：</strong>即使现在<code>__proto__</code>属性被标准化了，并且它更容易用于解释，但是在实践中对原型操作更喜欢用API方法，比如<code>Object.create</code>、<code>Object.getPrototypeOf</code>、<code>Object.setPrototypeOf</code>以及类似的<code>Reflect</code>模块。</p>
</blockquote>
<p>在<code>Object.prototype</code>示例中，我们看到<em>同样的原型</em>可以在<em>多个对象</em>之间共享。在这个原则的基础上，ECMAScript中就实现了<em>基于类的继承</em>。下面我们看看这个示例，看看JS中<code>"类"</code>概念背后的机制。</p>
<h2><a id="toc-fad" class="anchor" href="#toc-fad"></a>类</h2>
<p>当多个对象共享相同的初始状态以及行为时，它们就形成了一种<em>分类</em>（classification）。</p>
<p><strong>定义 5：类（class）：</strong>一个类是一种形式化的概念集合，指定其对象的初始状态和行为。</p>
<p>假如我们需要有<em>多个对象</em>，这些对象都继承自同一个原型，我们自然会先创建这个原型，然后显式从新创建的对象继承它：</p>
<pre><code class="hljs lang-typescript firekylin-code"><ul><li><span class="line-num" data-line="1"></span><span class="hljs-comment">// 所有字母的通用原型</span></li><li><span class="line-num" data-line="2"></span><span class="hljs-keyword">let</span> letter = {</li><li><span class="line-num" data-line="3"></span>  getNumber() {</li><li><span class="line-num" data-line="4"></span>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.number;</li><li><span class="line-num" data-line="5"></span>  }</li><li><span class="line-num" data-line="6"></span>};</li><li><span class="line-num" data-line="7"></span></li><li><span class="line-num" data-line="8"></span><span class="hljs-keyword">let</span> a = {<span class="hljs-built_in">number</span>: <span class="hljs-number">1</span>, __proto__: letter};</li><li><span class="line-num" data-line="9"></span><span class="hljs-keyword">let</span> b = {<span class="hljs-built_in">number</span>: <span class="hljs-number">2</span>, __proto__: letter};</li><li><span class="line-num" data-line="10"></span><span class="hljs-comment">// ...</span></li><li><span class="line-num" data-line="11"></span><span class="hljs-keyword">let</span> z = {<span class="hljs-built_in">number</span>: <span class="hljs-number">26</span>, __proto__: letter};</li><li><span class="line-num" data-line="12"></span></li><li><span class="line-num" data-line="13"></span><span class="hljs-built_in">console</span>.log(</li><li><span class="line-num" data-line="14"></span>  a.getNumber(), <span class="hljs-comment">// 1</span></li><li><span class="line-num" data-line="15"></span>  b.getNumber(), <span class="hljs-comment">// 2</span></li><li><span class="line-num" data-line="16"></span>  z.getNumber(), <span class="hljs-comment">// 26</span></li><li><span class="line-num" data-line="17"></span>);</li></ul><b class="name">typescript</b></code></pre><p>我们可以在下图看到这些关系：</p>
<p><img class="" src="http://www.xiaojichao.com/static/upload/20171215/SU2P1B47tErclAM2eYdJ.png" alt="alt"><noscript><img src="http://www.xiaojichao.com/static/upload/20171215/SU2P1B47tErclAM2eYdJ.png" alt="alt"></noscript></p>
<p>图 3. 共享的原型</p>
<p>不过，这显然<em>很麻烦</em>。而类正是干这事的，它作为一种语法糖（即在语义上做同样事情的构造，不过是以更好的语法形式），允许用方便的模式创建这样的多个对象：</p>
<pre><code class="hljs lang-typescript firekylin-code"><ul><li><span class="line-num" data-line="1"></span><span class="hljs-keyword">class</span> Letter {</li><li><span class="line-num" data-line="2"></span>  <span class="hljs-keyword">constructor</span>(<span class="hljs-params"><span class="hljs-built_in">number</span></span>) {</li><li><span class="line-num" data-line="3"></span>    <span class="hljs-keyword">this</span>.number = <span class="hljs-built_in">number</span>;</li><li><span class="line-num" data-line="4"></span>  }</li><li><span class="line-num" data-line="5"></span></li><li><span class="line-num" data-line="6"></span>  getNumber() {</li><li><span class="line-num" data-line="7"></span>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.number;</li><li><span class="line-num" data-line="8"></span>  }</li><li><span class="line-num" data-line="9"></span>}</li><li><span class="line-num" data-line="10"></span></li><li><span class="line-num" data-line="11"></span><span class="hljs-keyword">let</span> a = <span class="hljs-keyword">new</span> Letter(<span class="hljs-number">1</span>);</li><li><span class="line-num" data-line="12"></span><span class="hljs-keyword">let</span> b = <span class="hljs-keyword">new</span> Letter(<span class="hljs-number">2</span>);</li><li><span class="line-num" data-line="13"></span><span class="hljs-comment">// ...</span></li><li><span class="line-num" data-line="14"></span><span class="hljs-keyword">let</span> z = <span class="hljs-keyword">new</span> Letter(<span class="hljs-number">26</span>);</li><li><span class="line-num" data-line="15"></span></li><li><span class="line-num" data-line="16"></span><span class="hljs-built_in">console</span>.log(</li><li><span class="line-num" data-line="17"></span>  a.getNumber(), <span class="hljs-comment">// 1</span></li><li><span class="line-num" data-line="18"></span>  b.getNumber(), <span class="hljs-comment">// 2</span></li><li><span class="line-num" data-line="19"></span>  z.getNumber(), <span class="hljs-comment">// 26</span></li><li><span class="line-num" data-line="20"></span>);</li></ul><b class="name">typescript</b></code></pre><blockquote>
<p><strong>注：</strong>在ECMAScript中，<em>基于类的继承</em>是在<em>基于原型的代理</em>基础上实现的。</p>
<p><strong>注：*</strong>'类'<em>只是一个</em>理论上的概念<em>。从技术上讲，它可以用像在Java或者C++那样，用</em>静态调度<em>实现，或者像在JavaScript、Python、Ruby等中那样，用</em>动态调度（委托）*实现。</p>
</blockquote>
<p>从技术上讲，一个类被表示为一对<em>构造函数+原型</em>。因此，构造函数<em>创建对象</em>，同时还<em>自动</em>为它新创建的实例设置<em>原型</em>。这个原型被存储在<code>&lt;ConstructorFunction&gt;.prototype</code>属性中。</p>
<p><strong>定义 6：构造函数：*</strong>构造函数*是一个用于创建实例，并自动设置实例的原型的函数。</p>
<p>可以显式使用构造函数。而且，在引入类的概念之前，JS开发者过去也没有更好的替代品（我们依然可以在互联网上找到很多这样的遗留代码）：</p>
<pre><code class="hljs lang-javascript firekylin-code"><ul><li><span class="line-num" data-line="1"></span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Letter</span>(<span class="hljs-params">number</span>) </span>{</li><li><span class="line-num" data-line="2"></span>  <span class="hljs-keyword">this</span>.number = number;</li><li><span class="line-num" data-line="3"></span>}</li><li><span class="line-num" data-line="4"></span></li><li><span class="line-num" data-line="5"></span>Letter.prototype.getNumber = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{</li><li><span class="line-num" data-line="6"></span>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.number;</li><li><span class="line-num" data-line="7"></span>};</li><li><span class="line-num" data-line="8"></span></li><li><span class="line-num" data-line="9"></span><span class="hljs-keyword">let</span> a = <span class="hljs-keyword">new</span> Letter(<span class="hljs-number">1</span>);</li><li><span class="line-num" data-line="10"></span><span class="hljs-keyword">let</span> b = <span class="hljs-keyword">new</span> Letter(<span class="hljs-number">2</span>);</li><li><span class="line-num" data-line="11"></span><span class="hljs-comment">// ...</span></li><li><span class="line-num" data-line="12"></span><span class="hljs-keyword">let</span> z = <span class="hljs-keyword">new</span> Letter(<span class="hljs-number">26</span>);</li><li><span class="line-num" data-line="13"></span></li><li><span class="line-num" data-line="14"></span><span class="hljs-built_in">console</span>.log(</li><li><span class="line-num" data-line="15"></span>  a.getNumber(), <span class="hljs-comment">// 1</span></li><li><span class="line-num" data-line="16"></span>  b.getNumber(), <span class="hljs-comment">// 2</span></li><li><span class="line-num" data-line="17"></span>  z.getNumber(), <span class="hljs-comment">// 26</span></li><li><span class="line-num" data-line="18"></span>);</li></ul><b class="name">javascript</b></code></pre><p>而且虽然创建单层构造函数很容易，不过这种从父类继承的模式需要相当多的样板代码。目前这个样板代码是作为<em>实现细节</em>隐藏的，而这恰好就是在JavaScript创建类时背后发生的事情。</p>
<blockquote>
<p><strong>注：*</strong>构造函数<em>只是基于类的继承的</em>实现细节*。</p>
</blockquote>
<p>下面我们来看看对象及其类的关系：</p>
<p><img class="" src="http://www.xiaojichao.com/static/upload/20171215/8eu3YfzzUjnn736l4tAE.png" alt="alt"><noscript><img src="http://www.xiaojichao.com/static/upload/20171215/8eu3YfzzUjnn736l4tAE.png" alt="alt"></noscript></p>
<p>图 4. 构造函数和对象的关系</p>
<p>上图表明，<em>每个对象</em>都有一个相关的原型。甚至构造函数（类）<code>Letter</code>也有它自己的原型<code>Function.prototype</code>。注意，这个<code>Letter.prototype</code>是Letter的<em>实例</em>（即<code>a</code>、<code>b</code>和<code>z</code>）的原型。</p>
<blockquote>
<p><strong>注：*</strong>任何<em>对象的</em>实际<em>原型总是<code>__proto__</code>引用。而构造函数上的显式<code>prototype</code>属性只是一个对其</em>实例*的原型的引用；在实例上，它依然是被<code>__proto__</code>引用。详情请参见<a href="http://dmitrysoshnikov.com/ecmascript/chapter-7-2-oop-ecmascript-implementation/#explicit-codeprototypecode-and-implicit-codeprototypecode-properties">这里</a>。</p>
</blockquote>
<p>我们可以在<a href="http://dmitrysoshnikov.com/ecmascript/chapter-7-1-oop-general-theory/">ES3. 7.1 OOP：通用理论</a> 这篇文章中找到有关通用OOP概念的详细讨论（包括基于类、基于原型等的详细描述）。</p>
<p>现在我们已经理解了ECMAScript对象之间的基本关系，下面我们深入看看JS<em>运行时系统</em>。我们会看到，这里几乎所有东西也都可以被表示为对象。</p>
<h2><a id="toc-22a" class="anchor" href="#toc-22a"></a>执行上下文</h2>
<p>为执行JS代码，并跟踪其运行时求值，ECMAScript规范定义了<em>执行上下文</em>的概念。从逻辑上讲，执行上下文是用<em>栈</em>（<em>执行上下文栈</em>的简写）来维护的，栈与<em>调用栈</em>这个通用概念有关。</p>
<p><strong>定义 7：执行上下文（Execution Context）：</strong>执行上下文是用于跟踪运行时代码求值的一个规范设备。</p>
<p>ECMAScript代码有几种类型：<em>全局代码</em>、<em>函数代码</em>、<em><code>eval</code>代码</em>和<em>模块代码</em>；每种代码都是在其执行上下文中求值。不同的代码类型及其对应的对象可能会影响执行上下文的结构：比如，<em>generator函数</em>将其<em>generator对象</em>保存在上下文中。</p>
<p>下面我们考虑一个递归函数调用：</p>
<pre><code class="hljs lang-actionscript firekylin-code"><ul><li><span class="line-num" data-line="1"></span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">recursive</span><span class="hljs-params">(flag)</span> </span>{</li><li><span class="line-num" data-line="2"></span></li><li><span class="line-num" data-line="3"></span>  <span class="hljs-comment">// 退出条件</span></li><li><span class="line-num" data-line="4"></span>  <span class="hljs-keyword">if</span> (flag === <span class="hljs-number">2</span>) {</li><li><span class="line-num" data-line="5"></span>    <span class="hljs-keyword">return</span>;</li><li><span class="line-num" data-line="6"></span>  }</li><li><span class="line-num" data-line="7"></span></li><li><span class="line-num" data-line="8"></span>  <span class="hljs-comment">// 递归调用。</span></li><li><span class="line-num" data-line="9"></span>  recursive(++flag);</li><li><span class="line-num" data-line="10"></span>}</li><li><span class="line-num" data-line="11"></span></li><li><span class="line-num" data-line="12"></span><span class="hljs-comment">// Go.</span></li><li><span class="line-num" data-line="13"></span>recursive(<span class="hljs-number">0</span>);</li></ul><b class="name">actionscript</b></code></pre><p>当函数被调用时，就创建了一个<em>新的执行上下文</em>，并被<em>压</em>到栈中 - 此时，它变成一个<em>活动的执行上下文</em>。当函数返回时，其上下文被从栈中<em>弹出</em>。</p>
<p>调用另一个上下文的上下文被称为<em>调用者</em>（caller）。被调用的上下文相应地被称为<em>被调用者</em>（callee）。在我们的例子中，<code>recursive</code>函数在递归调用它本身时，同时扮演了这两个角色：既是调用者，又是被调用者。</p>
<p><strong>定义 8：执行上下文栈：*</strong>执行上下文栈*是一种LIFO（后进先出）结构，用于维护控制流程和执行顺序。</p>
<p>对于上面的例子，有如下的栈<em>"压入-弹出"</em>变动图：</p>
<p><img class="" src="http://www.xiaojichao.com/static/upload/20171215/pVd7fNaNvTzy_r_jWCk3.png" alt="alt"><noscript><img src="http://www.xiaojichao.com/static/upload/20171215/pVd7fNaNvTzy_r_jWCk3.png" alt="alt"></noscript></p>
<p>图 5. 执行上下文栈</p>
<p>从图中我们还可以看到，<em>全局上下文</em>（Global context）总是在栈的底部，它是由之前任何其它上下文的执行创建的。</p>
<p>我们可以在<a href="http://dmitrysoshnikov.com/ecmascript/chapter-1-execution-contexts/">对应的章</a>找到执行上下文的更多详细资料。</p>
<p>通常，一个上下文的代码会一直运行到结束，不过正如我们上面提到过的，有些对象，比如generator，可能会违反栈的LIFO顺序。一个generator函数可能会挂起其正在执行的上下文，并在结束前将其从栈中删除。一旦generator再次激活，它上下文就被回复，并再次压入栈中：</p>
<pre><code class="hljs lang-javascript firekylin-code"><ul><li><span class="line-num" data-line="1"></span><span class="hljs-function"><span class="hljs-keyword">function</span> *<span class="hljs-title">gen</span>(<span class="hljs-params"></span>) </span>{</li><li><span class="line-num" data-line="2"></span>  <span class="hljs-keyword">yield</span> <span class="hljs-number">1</span>;</li><li><span class="line-num" data-line="3"></span>  <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;</li><li><span class="line-num" data-line="4"></span>}</li><li><span class="line-num" data-line="5"></span></li><li><span class="line-num" data-line="6"></span><span class="hljs-keyword">let</span> g = gen();</li><li><span class="line-num" data-line="7"></span></li><li><span class="line-num" data-line="8"></span><span class="hljs-built_in">console</span>.log(</li><li><span class="line-num" data-line="9"></span>  g.next().value, <span class="hljs-comment">// 1</span></li><li><span class="line-num" data-line="10"></span>  g.next().value, <span class="hljs-comment">// 2</span></li><li><span class="line-num" data-line="11"></span>);</li></ul><b class="name">javascript</b></code></pre><p>这里的<code>yield</code>语句将值返回给调用者，并弹出上下文。在第二个<code>next</code>调用时，同一个上下文被再次压入栈中，并恢复。这样的上下文可能会比创建它的调用者活得长，所以会违反LIFO结构。</p>
<blockquote>
<p><strong>注：</strong>我们可以在<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Iterators_and_Generators">这个文档</a>中阅读有关generator和iterator的更多资料。</p>
</blockquote>
<p>下面我们要讨论执行上下文的最重要的部分；特别是我们应该看到ECMAScript运行时如何管理变量存储以及由嵌套代码块创建的作用域。这就是<em>词法环境</em>的通常概念，它用来在JS中存储数据，并用<em>闭包</em>的机制解决<em>'Funarg问题'</em>。</p>
<h2><a id="toc-fa4" class="anchor" href="#toc-fa4"></a>环境</h2>
<p>每个执行上下文都有一个相关联的<em>词法环境</em>。</p>
<p><strong>定义 9：词法环境（lexical environment）：</strong>词法环境是一种用于定义出现在上下文中的<em>标识符</em>与其值之间的关联的结构。每个环境有一个对<em>可选的父环境</em>的引用。</p>
<p>所以，环境就是定义在一个作用域中的变量、函数和类的<em>仓库</em>（storage）。</p>
<p>从技术上讲，环境是由<em>一对**环境记录（Environment Record）</em>（一个将标识符映射到值的实际存储表）以及对父的引用（可能是<code>null</code>）组成的。</p>
<p>对于如下代码：</p>
<pre><code class="hljs lang-javascript firekylin-code"><ul><li><span class="line-num" data-line="1"></span><span class="hljs-keyword">let</span> x = <span class="hljs-number">10</span>;</li><li><span class="line-num" data-line="2"></span><span class="hljs-keyword">let</span> y = <span class="hljs-number">20</span>;</li><li><span class="line-num" data-line="3"></span></li><li><span class="line-num" data-line="4"></span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params">z</span>) </span>{</li><li><span class="line-num" data-line="5"></span>  <span class="hljs-keyword">let</span> x = <span class="hljs-number">100</span>;</li><li><span class="line-num" data-line="6"></span>  <span class="hljs-keyword">return</span> x + y + z;</li><li><span class="line-num" data-line="7"></span>}</li><li><span class="line-num" data-line="8"></span></li><li><span class="line-num" data-line="9"></span>foo(<span class="hljs-number">30</span>); <span class="hljs-comment">// 150</span></li></ul><b class="name">javascript</b></code></pre><p><em>全局上下文</em>以及<code>foo</code>函数的上下文的环境结构看起来会像下面这样：</p>
<p><img class="" src="http://www.xiaojichao.com/static/upload/20171215/_4_iCT4i2nWck7DXOB3_.png" alt="alt"><noscript><img src="http://www.xiaojichao.com/static/upload/20171215/_4_iCT4i2nWck7DXOB3_.png" alt="alt"></noscript></p>
<p>图 6. 环境链</p>
<p>在逻辑上讲，这会让我们回想起了上面已经讨论过的<em>原型链</em>。而<em>标识符解析</em>的规则是很相似的：如果一个变量在<em>自己的</em>环境中<em>找不到</em>，就试着在<em>父环境</em>、父环境的父环境中查找它，依此类推，直到查完整个<em>环境链</em>。</p>
<p><strong>定义 10：标识符解析（Identifier Resolution）：</strong>在一个环境链中解析一个变量<em>（绑定）</em>的过程。一个解析不出来的绑定会导致<code>ReferenceError</code>。</p>
<p>这就解释了为什么变量<code>x</code>被解析为<code>100</code>，而不是<code>10</code>？因为它是直接在<code>foo</code>的<em>自身</em>环境中找到的；为什么可以访问参数<code>z</code>？因为它也是只存储在<em>激活环境</em>（activation environment）中；为什么我们还可以访问变量<code>y</code>？因为它是在父环境中找到的。</p>
<p>与原型类似，同一个父环境可以被几个子环境共享：比如，两个全局函数共享同一个全局环境。</p>
<blockquote>
<p>注：有关词法环境的详细信息可以参考<a href="http://dmitrysoshnikov.com/ecmascript/es5-chapter-3-2-lexical-environments-ecmascript-implementation/">本文</a>.</p>
</blockquote>
<p>环境记录根据类型而有所不同。有<strong>对象</strong>环境记录和<strong>声明式</strong>环境记录。在声明式记录之上，还有<strong>函数</strong>环境记录和<strong>模块</strong>环境记录。每种类型的记录都有其特定的属性。不过，标识符解析的通用机制对于所有环境都是通用的，并且不依赖于记录的类型。</p>
<p><em>全局环境</em>的记录就是<em>对象环境记录</em>的一个例子。这样的记录也有关联的<em>绑定对象</em>，该对象会存储一些来自该记录的属性，但是不会存储来自其它记录的属性，反之亦然。绑定对象也可以被提供为<code>this</code>值。</p>
<pre><code class="hljs lang-javascript firekylin-code"><ul><li><span class="line-num" data-line="1"></span><span class="hljs-comment">// 旧式用`var`声明的变量。</span></li><li><span class="line-num" data-line="2"></span><span class="hljs-keyword">var</span> x = <span class="hljs-number">10</span>;</li><li><span class="line-num" data-line="3"></span></li><li><span class="line-num" data-line="4"></span><span class="hljs-comment">// 现代用`let`声明的变量。</span></li><li><span class="line-num" data-line="5"></span><span class="hljs-keyword">let</span> y = <span class="hljs-number">20</span>;</li><li><span class="line-num" data-line="6"></span></li><li><span class="line-num" data-line="7"></span><span class="hljs-comment">// 二者都被添加到环境记录：</span></li><li><span class="line-num" data-line="8"></span><span class="hljs-built_in">console</span>.log(</li><li><span class="line-num" data-line="9"></span>  x, <span class="hljs-comment">// 10</span></li><li><span class="line-num" data-line="10"></span>  y, <span class="hljs-comment">// 20</span></li><li><span class="line-num" data-line="11"></span>);</li><li><span class="line-num" data-line="12"></span></li><li><span class="line-num" data-line="13"></span><span class="hljs-comment">// 但是只有`x`被添加到"绑定对象"。</span></li><li><span class="line-num" data-line="14"></span><span class="hljs-comment">// 全局环境的绑定对象是鳏居对象，等于`this`：</span></li><li><span class="line-num" data-line="15"></span></li><li><span class="line-num" data-line="16"></span><span class="hljs-built_in">console</span>.log(</li><li><span class="line-num" data-line="17"></span>  <span class="hljs-keyword">this</span>.x, <span class="hljs-comment">// 10</span></li><li><span class="line-num" data-line="18"></span>  <span class="hljs-keyword">this</span>.y, <span class="hljs-comment">// undefined!</span></li><li><span class="line-num" data-line="19"></span>);</li><li><span class="line-num" data-line="20"></span></li><li><span class="line-num" data-line="21"></span><span class="hljs-comment">// 绑定对象可以存储一个名称，该名称不添加到环境记录，</span></li><li><span class="line-num" data-line="22"></span><span class="hljs-comment">// 因为它不是一个有效的标识符：</span></li><li><span class="line-num" data-line="23"></span></li><li><span class="line-num" data-line="24"></span><span class="hljs-keyword">this</span>[<span class="hljs-string">'not valid ID'</span>] = <span class="hljs-number">30</span>;</li><li><span class="line-num" data-line="25"></span></li><li><span class="line-num" data-line="26"></span><span class="hljs-built_in">console</span>.log(</li><li><span class="line-num" data-line="27"></span>  <span class="hljs-keyword">this</span>[<span class="hljs-string">'not valid ID'</span>], <span class="hljs-comment">// 30</span></li><li><span class="line-num" data-line="28"></span>);</li></ul><b class="name">javascript</b></code></pre><p>可以用下图来描述：</p>
<p><img class="" src="http://www.xiaojichao.com/static/upload/20171215/tJEx2IUIGj7bocEq3rL3.png" alt="alt"><noscript><img src="http://www.xiaojichao.com/static/upload/20171215/tJEx2IUIGj7bocEq3rL3.png" alt="alt"></noscript></p>
<p>图 7. 绑定对象</p>
<p>注意，绑定对象的存在是为了涵盖<em>旧式构造</em>（比如<code>var</code>声明和<code>with</code>语句），这种构造也将其对象作为绑定对象提供。这些是环境被表示为简单对象时的历史原因。当前的环境模型更加优化，不过结果是我们再也不能将绑定当作属性来访问了。</p>
<p>我们已经看到环境是如何通过父链接关联。下面我们将看到环境如何比创建它的上下文存活得更久，这是我们将要讨论的<em>闭包</em>机制的基础。</p>
<h2><a id="toc-0ed" class="anchor" href="#toc-0ed"></a>闭包</h2>
<p>ECMAScript中的函数是<em>一等公民</em>。这个概念是<em>函数式编程</em>的基础，而JavaScript中是支持函数式编程的。</p>
<p><strong>定义. 11：一等函数（First-class Function）：</strong>可以作为普通数据参与的一个函数：可以存储在一个变量中，作为实参传递、或者作为另一个函数的返回值返回。</p>
<p>与一等函数相关的是所谓<a href="https://en.wikipedia.org/wiki/Funarg_problem">"Funarg问题"</a>（或者<em>"函数式实参问题"</em>）。这个问题是在函数不得不处理<em>自由变量</em>时候出现的。</p>
<p><strong>定义. 12：自由变量（Free Variable）：</strong>一个既不是函数的形参，也不是函数的局部变量的变量。</p>
<p>下面我们来看看Funarg问题，看看在ECMAScript中如何解决这个问题。</p>
<p>考虑如下的代码段：</p>
<pre><code class="hljs lang-javascript firekylin-code"><ul><li><span class="line-num" data-line="1"></span><span class="hljs-keyword">let</span> x = <span class="hljs-number">10</span>;</li><li><span class="line-num" data-line="2"></span></li><li><span class="line-num" data-line="3"></span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>{</li><li><span class="line-num" data-line="4"></span>  <span class="hljs-built_in">console</span>.log(x);</li><li><span class="line-num" data-line="5"></span>}</li><li><span class="line-num" data-line="6"></span></li><li><span class="line-num" data-line="7"></span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bar</span>(<span class="hljs-params">funArg</span>) </span>{</li><li><span class="line-num" data-line="8"></span>  <span class="hljs-keyword">let</span> x = <span class="hljs-number">20</span>;</li><li><span class="line-num" data-line="9"></span>  funArg(); <span class="hljs-comment">// 10, 而不是20!</span></li><li><span class="line-num" data-line="10"></span>}</li><li><span class="line-num" data-line="11"></span></li><li><span class="line-num" data-line="12"></span><span class="hljs-comment">// 将 `foo` 作为实参传给 `bar`。</span></li><li><span class="line-num" data-line="13"></span>bar(foo);</li></ul><b class="name">javascript</b></code></pre><p>对于函数<code>foo</code>，变量<code>x</code>就是自由变量。当<code>foo</code>函数被激活时（通过<code>funArg</code>形参），它在哪里解析<code>x</code>绑定呢？是从创建函数的外层作用域，还是从调用者作用域，还是从函数被调用的地方？我们可以看到，调用者<code>bar</code>函数也提供了对<code>x</code>的绑定（值为<code>20</code>）。</p>
<p>上面描述的情况称为<em>向下funarg问题</em>，即在判断绑定的正确环境时的歧义性：它应该是创建时的环境，还是调用时的环境？</p>
<p>这是通过达成协议使用<em>静态作用域</em>来解决的，静态作用域是<em>创建时</em>的作用域。</p>
<p><strong>定义 13：静态作用域：</strong>如果一个语言只通过查找源代码，就可以判断绑定在哪个环境中解析，那么该语言就实现了<em>静态作用域</em>。</p>
<p>静态作用域有时也称为<em>词法作用域</em>，这也是<em>词法环境</em>这个名称的由来。</p>
<p>从技术上讲，静态作用域是通过捕获函数创建所在的环境来实现的。</p>
<blockquote>
<p><strong>注：</strong>可以在<a href="https://codeburst.io/js-scope-static-dynamic-and-runtime-augmented-5abfee6223fe">本文</a>中阅读有关静态和动态作用域知识。</p>
</blockquote>
<p>在我们的例子中，<code>foo</code>函数捕获的环境是<em>全局环境</em>：</p>
<p><img class="" src="http://www.xiaojichao.com/static/upload/20171215/PBqF_feKYscDGgp6sen_.png" alt="alt"><noscript><img src="http://www.xiaojichao.com/static/upload/20171215/PBqF_feKYscDGgp6sen_.png" alt="alt"></noscript></p>
<p>图 8. 闭包</p>
<p>我们可以看到，一个环境引用一个函数，而这个函数又引用<em>回</em>该环境。</p>
<p><strong>定义. 14：闭包：*</strong>闭包<em>是一个函数捕获它被定义时所在的环境。这个环境被用于</em>标识符解析*。</p>
<blockquote>
<p><strong>注：</strong>一个函数是在一个新的激活环境中被调用的，这个环境存储了<em>本地变量</em>和<em>实参</em>。该激活环境的<em>父环境</em>被设置为该函数的<em>闭合环境</em>，从而有了<em>词法作用域</em>的语义。</p>
</blockquote>
<p>Funarg问题的第二种子类型被称为<strong>向上funarg问题</strong>。这里唯一的区别是捕获的环境比创建它的上下文存活得更久。</p>
<p>下面我们看一个例子：</p>
<pre><code class="hljs lang-javascript firekylin-code"><ul><li><span class="line-num" data-line="1"></span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>{</li><li><span class="line-num" data-line="2"></span>  <span class="hljs-keyword">let</span> x = <span class="hljs-number">10</span>;</li><li><span class="line-num" data-line="3"></span></li><li><span class="line-num" data-line="4"></span>  <span class="hljs-comment">// 闭包，捕获`foo`的环境。</span></li><li><span class="line-num" data-line="5"></span>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bar</span>(<span class="hljs-params"></span>) </span>{</li><li><span class="line-num" data-line="6"></span>    <span class="hljs-keyword">return</span> x;</li><li><span class="line-num" data-line="7"></span>  }</li><li><span class="line-num" data-line="8"></span></li><li><span class="line-num" data-line="9"></span>  <span class="hljs-comment">// 向上funarg。</span></li><li><span class="line-num" data-line="10"></span>  <span class="hljs-keyword">return</span> bar;</li><li><span class="line-num" data-line="11"></span>}</li><li><span class="line-num" data-line="12"></span></li><li><span class="line-num" data-line="13"></span><span class="hljs-keyword">let</span> x = <span class="hljs-number">20</span>;</li><li><span class="line-num" data-line="14"></span></li><li><span class="line-num" data-line="15"></span><span class="hljs-comment">// 调用`foo`来返回`bar`闭包。</span></li><li><span class="line-num" data-line="16"></span><span class="hljs-keyword">let</span> bar = foo();</li><li><span class="line-num" data-line="17"></span></li><li><span class="line-num" data-line="18"></span>bar(); <span class="hljs-comment">// 10，而不是20!</span></li></ul><b class="name">javascript</b></code></pre><p>同样，从技术上讲，它与捕获定义环境的确切机制没有什么不同。就在这种情况下，如果没有闭包，<code>foo</code>的激活环境将被销毁。但我们捕获了它，所以它<em>不能被释放</em>，并保留下来，以支持<em>静态作用域</em>语义。</p>
<p>对闭包的理解经常不完整 - 开发者通常认为闭包只是与向上的funarg问题有关（实际上它确实更有意义）。不过，正如我们所见，<em>向下</em>和<em>向上funarg问题</em>的技术机制是<em>完全相同的</em>，就是<em>静态作用域的机制</em>。</p>
<p>正如我们上面所提到的，与原型相似，同一个父环境可以在几个闭包之间共享。这样，就可以访问和修改共享的数据：</p>
<pre><code class="hljs lang-swift firekylin-code"><ul><li><span class="line-num" data-line="1"></span>function createCounter() {</li><li><span class="line-num" data-line="2"></span>  <span class="hljs-keyword">let</span> <span class="hljs-built_in">count</span> = <span class="hljs-number">0</span>;</li><li><span class="line-num" data-line="3"></span></li><li><span class="line-num" data-line="4"></span>  <span class="hljs-keyword">return</span> {</li><li><span class="line-num" data-line="5"></span>    increment() { <span class="hljs-built_in">count</span>++; <span class="hljs-keyword">return</span> <span class="hljs-built_in">count</span>; },</li><li><span class="line-num" data-line="6"></span>    decrement() { <span class="hljs-built_in">count</span>--; <span class="hljs-keyword">return</span> <span class="hljs-built_in">count</span>; },</li><li><span class="line-num" data-line="7"></span>  };</li><li><span class="line-num" data-line="8"></span>}</li><li><span class="line-num" data-line="9"></span></li><li><span class="line-num" data-line="10"></span><span class="hljs-keyword">let</span> counter = createCounter();</li><li><span class="line-num" data-line="11"></span></li><li><span class="line-num" data-line="12"></span>console.log(</li><li><span class="line-num" data-line="13"></span>  counter.increment(), <span class="hljs-comment">// 1</span></li><li><span class="line-num" data-line="14"></span>  counter.decrement(), <span class="hljs-comment">// 0</span></li><li><span class="line-num" data-line="15"></span>  counter.increment(), <span class="hljs-comment">// 1</span></li><li><span class="line-num" data-line="16"></span>);</li></ul><b class="name">swift</b></code></pre><p>因为两个闭包<code>increment</code>和<code>decrement</code>都是在包含<code>count</code>变量的作用域内创建的，所以它们<em>共享</em>这个<em>父作用域</em>。即，捕获总是<em>通过引用</em>发生的，也就是说对<em>整个父环境</em>的<em>引用</em>被存储下来了。</p>
<p>我们可以在下图看到：</p>
<p><img class="" src="http://www.xiaojichao.com/static/upload/20171215/jIMFbP0F5OERZyFRxT5H.png" alt="alt"><noscript><img src="http://www.xiaojichao.com/static/upload/20171215/jIMFbP0F5OERZyFRxT5H.png" alt="alt"></noscript></p>
<p>图 9. 一个共享的环境</p>
<p>有些语言会<em>通过值</em>捕获，给被捕获的变量做个副本，并且不允许在父作用域中修改它。不过在JS中，再说一遍，它总是对父作用域的<em>引用</em>。</p>
<blockquote>
<p><strong>注：</strong>JS引擎实现可能会优化这个步骤，并且不会捕获整个环境，只捕获要用的自由变量，然后依然在父作用域中维护可变数据的不变量。</p>
</blockquote>
<p>有关闭包和Funarg问题的详细讨论，可以在<a href="http://dmitrysoshnikov.com/ecmascript/chapter-6-closures/">对应的章节</a>中找到。</p>
<p>所以所有标识符都是静态作用域的。不过，在ECMAScript中有一个值是<em>动态作用域</em>的。就是<code>this</code>的值。</p>
<h2><a id="this" class="anchor" href="#this"></a>This</h2>
<p><code>this</code>值是一个<em>动态</em>并<em>隐式</em>传给一个上下文的代码的特殊对象。我们可以把它当作是一个<em>隐式的额外形参</em>，能够访问，但是不能修改。</p>
<p><code>this</code>值的用途是为多个对象执行相同的代码。</p>
<p><strong>定义 15：this：</strong><code>this</code>是一个隐式的<em>上下文对象</em>，可以从一个执行上下文的代码中访问，从而可以为多个对象应用相同的代码。</p>
<p>主要的使用案例是基于类的OOP。一个实例方法（在原型中定义的）存在于<em>一个标本</em>中，但是在该类的<em>所有实例</em>中<em>共享</em>。</p>
<pre><code class="hljs lang-javascript firekylin-code"><ul><li><span class="line-num" data-line="1"></span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Point</span> </span>{</li><li><span class="line-num" data-line="2"></span>  <span class="hljs-keyword">constructor</span>(x, y) {</li><li><span class="line-num" data-line="3"></span>    <span class="hljs-keyword">this</span>._x = x;</li><li><span class="line-num" data-line="4"></span>    <span class="hljs-keyword">this</span>._y = y;</li><li><span class="line-num" data-line="5"></span>  }</li><li><span class="line-num" data-line="6"></span></li><li><span class="line-num" data-line="7"></span>  getX() {</li><li><span class="line-num" data-line="8"></span>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._x;</li><li><span class="line-num" data-line="9"></span>  }</li><li><span class="line-num" data-line="10"></span></li><li><span class="line-num" data-line="11"></span>  getY() {</li><li><span class="line-num" data-line="12"></span>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._y;</li><li><span class="line-num" data-line="13"></span>  }</li><li><span class="line-num" data-line="14"></span>}</li><li><span class="line-num" data-line="15"></span></li><li><span class="line-num" data-line="16"></span><span class="hljs-keyword">let</span> p1 = <span class="hljs-keyword">new</span> Point(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);</li><li><span class="line-num" data-line="17"></span><span class="hljs-keyword">let</span> p2 = <span class="hljs-keyword">new</span> Point(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>);</li><li><span class="line-num" data-line="18"></span></li><li><span class="line-num" data-line="19"></span><span class="hljs-comment">// 这两个实例中都可以访问`getX`和`getY`（两个实例都被作为`this`传递）</span></li><li><span class="line-num" data-line="20"></span></li><li><span class="line-num" data-line="21"></span><span class="hljs-built_in">console</span>.log(</li><li><span class="line-num" data-line="22"></span>  p1.getX(), <span class="hljs-comment">// 1</span></li><li><span class="line-num" data-line="23"></span>  p2.getX(), <span class="hljs-comment">// 3</span></li><li><span class="line-num" data-line="24"></span>);</li></ul><b class="name">javascript</b></code></pre><p>当<code>getX</code>方法被激活时，就会创建一个新的环境存储本地变量和形参。此外，<em>函数环境记录</em>得到了传过来的<code>[[ThisValue]]</code>，这个this值是根据函数调用的方式<em>动态</em>绑定的。当该函数是用<code>p1</code>调用时，<code>this</code>值就是<code>p1</code>，而第二种情况下就是<code>p2</code>。</p>
<p><code>this</code>的另一种应用就是<em>通用的接口函数</em>，可以用在<em>mixins</em>或者<em>traits</em>中。</p>
<p>在如下的例子中，<code>Movable</code>接口包含通用函数<code>move</code>，其中<code>_x</code>和<code>_y</code>属性留给这个mixin的用户实现：</p>
<pre><code class="hljs lang-pony firekylin-code"><ul><li><span class="line-num" data-line="1"></span><span class="hljs-comment">// 通用的Movable接口（mixin）。</span></li><li><span class="line-num" data-line="2"></span><span class="hljs-keyword">let</span> <span class="hljs-type">Movable</span> = {</li><li><span class="line-num" data-line="3"></span></li><li><span class="line-num" data-line="4"></span>  <span class="hljs-comment">/**</span></li><li><span class="line-num" data-line="5"></span>   * 这个函数是通用的，可以与提供`_x`和`_y`属性的任何对象一起用，</li><li><span class="line-num" data-line="6"></span>   * 不管该对象的class是什么。</li><li><span class="line-num" data-line="7"></span>   */</li><li><span class="line-num" data-line="8"></span>  move(x, y) {</li><li><span class="line-num" data-line="9"></span>    <span class="hljs-literal">this</span>._x = x;</li><li><span class="line-num" data-line="10"></span>    <span class="hljs-literal">this</span>._y = y;</li><li><span class="line-num" data-line="11"></span>  },</li><li><span class="line-num" data-line="12"></span>};</li><li><span class="line-num" data-line="13"></span></li><li><span class="line-num" data-line="14"></span><span class="hljs-keyword">let</span> p1 = <span class="hljs-function"><span class="hljs-keyword">new</span> <span class="hljs-title">Point</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);</span></li><li><span class="line-num" data-line="15"></span></li><li><span class="line-num" data-line="16"></span><span class="hljs-comment">// 让 `p1` movable.</span></li><li><span class="line-num" data-line="17"></span><span class="hljs-title">Object</span>.<span class="hljs-title">assign</span>(p1, <span class="hljs-type">Movable</span>);</li><li><span class="line-num" data-line="18"></span></li><li><span class="line-num" data-line="19"></span><span class="hljs-comment">// 可以访问 `move` 方法。</span></li><li><span class="line-num" data-line="20"></span><span class="hljs-title">p1</span>.<span class="hljs-title">move</span>(<span class="hljs-number">100</span>, <span class="hljs-number">200</span>);</li><li><span class="line-num" data-line="21"></span></li><li><span class="line-num" data-line="22"></span><span class="hljs-title">console</span>.<span class="hljs-title">log</span>(p1.getX()); <span class="hljs-comment">// 100</span></li></ul><b class="name">pony</b></code></pre><p>作为替代方案，mixin还可以应用在<em>原型级</em>，而不是像上例中那样在<em>每个实例</em>上。</p>
<p>为展示<code>this</code>值的动态性质，考虑下例，我们留给读者作为要解决的一个练习：</p>
<pre><code class="hljs lang-gauss firekylin-code"><ul><li><span class="line-num" data-line="1"></span>function foo() {</li><li><span class="line-num" data-line="2"></span>  <span class="hljs-keyword">return</span> this;</li><li><span class="line-num" data-line="3"></span>}</li><li><span class="line-num" data-line="4"></span></li><li><span class="line-num" data-line="5"></span><span class="hljs-keyword">let</span> <span class="hljs-built_in">bar</span> = {</li><li><span class="line-num" data-line="6"></span>  foo,</li><li><span class="line-num" data-line="7"></span></li><li><span class="line-num" data-line="8"></span>  baz() {</li><li><span class="line-num" data-line="9"></span>    <span class="hljs-keyword">return</span> this;</li><li><span class="line-num" data-line="10"></span>  },</li><li><span class="line-num" data-line="11"></span>};</li><li><span class="line-num" data-line="12"></span></li><li><span class="line-num" data-line="13"></span><span class="hljs-comment">// `foo`</span></li><li><span class="line-num" data-line="14"></span>console.<span class="hljs-built_in">log</span>(</li><li><span class="line-num" data-line="15"></span>  foo(),       <span class="hljs-comment">// 全局或者undefined</span></li><li><span class="line-num" data-line="16"></span></li><li><span class="line-num" data-line="17"></span>  <span class="hljs-built_in">bar</span>.foo(),   <span class="hljs-comment">// bar</span></li><li><span class="line-num" data-line="18"></span>  (<span class="hljs-built_in">bar</span>.foo)(), <span class="hljs-comment">// bar</span></li><li><span class="line-num" data-line="19"></span></li><li><span class="line-num" data-line="20"></span>  (<span class="hljs-built_in">bar</span>.foo = <span class="hljs-built_in">bar</span>.foo)(), <span class="hljs-comment">// 全局</span></li><li><span class="line-num" data-line="21"></span>);</li><li><span class="line-num" data-line="22"></span></li><li><span class="line-num" data-line="23"></span><span class="hljs-comment">// `bar.baz`</span></li><li><span class="line-num" data-line="24"></span>console.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">bar</span>.baz()); <span class="hljs-comment">// bar</span></li><li><span class="line-num" data-line="25"></span></li><li><span class="line-num" data-line="26"></span><span class="hljs-keyword">let</span> savedBaz = <span class="hljs-built_in">bar</span>.baz;</li><li><span class="line-num" data-line="27"></span>console.<span class="hljs-built_in">log</span>(savedBaz()); <span class="hljs-comment">// 全局</span></li></ul><b class="name">gauss</b></code></pre><p>因为当<code>foo</code>在一个特定调用中时，只通过查看<code>foo</code>函数的源代码，我们不能没法说出<code>this</code>的值是什么，所以我们说<code>this</code>值是<em>动态作用域</em>。</p>
<blockquote>
<p><strong>注：</strong> 我们可以在<a href="http://dmitrysoshnikov.com/ecmascript/chapter-3-this/">对应的章</a>中，得到关于如何判断<code>this</code>值，以及为什么上面的代码会按那样的方式工作的详细解释。</p>
</blockquote>
<p><strong>箭头函数</strong>的<code>this</code>值是特殊的：其<code>this</code>是<em>词法（静态</em>）的，而不是<em>动态的</em>。即，它们的函数环境记录不会提供<code>this</code>值，而是来自于<em>父环境</em>。</p>
<pre><code class="hljs lang-coffeescript firekylin-code"><ul><li><span class="line-num" data-line="1"></span>var x = <span class="hljs-number">10</span>;</li><li><span class="line-num" data-line="2"></span></li><li><span class="line-num" data-line="3"></span>let foo = {</li><li><span class="line-num" data-line="4"></span>  x: <span class="hljs-number">20</span>,</li><li><span class="line-num" data-line="5"></span></li><li><span class="line-num" data-line="6"></span>  <span class="hljs-regexp">//</span> 动态 `<span class="javascript"><span class="hljs-keyword">this</span></span>`.</li><li><span class="line-num" data-line="7"></span>  bar() {</li><li><span class="line-num" data-line="8"></span>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.x;</li><li><span class="line-num" data-line="9"></span>  },</li><li><span class="line-num" data-line="10"></span></li><li><span class="line-num" data-line="11"></span>  <span class="hljs-regexp">//</span> 词法 `<span class="javascript"><span class="hljs-keyword">this</span></span>`.</li><li><span class="line-num" data-line="12"></span>  baz: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-keyword">this</span>.x,</li><li><span class="line-num" data-line="13"></span></li><li><span class="line-num" data-line="14"></span>  qux() {</li><li><span class="line-num" data-line="15"></span>    <span class="hljs-regexp">//</span> 调用内的词法<span class="hljs-keyword">this</span>。</li><li><span class="line-num" data-line="16"></span>    let arrow = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-keyword">this</span>.x;</li><li><span class="line-num" data-line="17"></span></li><li><span class="line-num" data-line="18"></span>    <span class="hljs-keyword">return</span> arrow();</li><li><span class="line-num" data-line="19"></span>  },</li><li><span class="line-num" data-line="20"></span>};</li><li><span class="line-num" data-line="21"></span></li><li><span class="line-num" data-line="22"></span><span class="hljs-built_in">console</span>.log(</li><li><span class="line-num" data-line="23"></span>  foo.bar(), <span class="hljs-regexp">//</span> <span class="hljs-number">20</span>, 来自 `<span class="javascript">foo</span>`</li><li><span class="line-num" data-line="24"></span>  foo.baz(), <span class="hljs-regexp">//</span> <span class="hljs-number">10</span>, 来自 <span class="hljs-built_in">global</span></li><li><span class="line-num" data-line="25"></span>  foo.qux(), <span class="hljs-regexp">//</span> <span class="hljs-number">20</span>, 来自 `<span class="javascript">foo</span>` 和箭头函数</li><li><span class="line-num" data-line="26"></span>);</li></ul><b class="name">coffeescript</b></code></pre><p>就像我们说过的那样，在<em>全局上下文</em>中，<code>this</code>是<em>全局对象</em>（<em>全局环境记录</em>的<em>绑定对象</em>）。以前只有一个全局对象，而在当前版本的规范中，可能有<em>多个全局对象</em>，这些全局对象都是<em>代码域</em>的一部分。下面我们来讨论一下这种结构。</p>
<h2><a id="toc-aa6" class="anchor" href="#toc-aa6"></a>域</h2>
<p>在求值之前，所有ECMAScript代码必须与一个域关联。从技术上讲，域只是为一个上下文提供全局环境。</p>
<p><strong>定义 16：域（Realm）：*</strong>代码域<em>是一个封装了单独的</em>全局环境*的对象。</p>
<p>当一个执行上下文被创建时，就与一个特定的代码域关联起来。这个代码域为该上下文提供<em>全局环境</em>。而且这种关联保持不变。</p>
<blockquote>
<p><strong>注：</strong>域在浏览器环境中的一个直接等价物就是<code>iframe</code>元素，该元素恰好就是提供一个自定义的全局环境。在Node.js中，接近于<a href="https://nodejs.org/api/vm.html">VM模块</a>的沙箱。</p>
</blockquote>
<p>当前版本的规范并没有提供显式创建域的能力，不过可以通过实现隐式创建。不过已经有一个<a href="https://github.com/tc39/proposal-realms/">提案</a> 要暴露这个API给用户代码。</p>
<p>不过从逻辑上讲，从栈中的每个上下文总是与它的域关联：</p>
<p><img class="" src="http://www.xiaojichao.com/static/upload/20171215/xqSuEWr4cimKRoXxRMC_.png" alt="alt"><noscript><img src="http://www.xiaojichao.com/static/upload/20171215/xqSuEWr4cimKRoXxRMC_.png" alt="alt"></noscript></p>
<p>图 10. 上下文和域的关联</p>
<p>现在我们正在接近ECMAScript运行时的较大的蓝图了。不过，我们依然需要看看代码的<em>入口点</em>，以及<em>初始化过程</em>。这是由<em>作业</em>和<em>作业队列</em>的机制管理的。</p>
<h2><a id="toc-116" class="anchor" href="#toc-116"></a>作业</h2>
<p>有些操作可以推迟，并在执行上下文栈上有可用点时执行。</p>
<p><strong>定义 17：作业：</strong>作业（job）是一种抽象操作，它在没有其它ECMAScript计算正在进行时启动一个ECMAScript计算。</p>
<p>作业在<strong>作业队列</strong>中排队，在当前版本的规范中，有两种作业队列：<strong>ScriptJobs</strong>和<strong>PromiseJobs</strong>。</p>
<p>而<em>ScriptJobs</em>队列上的<em>初始作业</em>是我们程序的<em>主入口点</em> - 加载和求值的初始脚本：创建域，创建全局上下文并与该域关联在一起，压到栈中，执行全局代码。</p>
<p>注意，ScriptJobs队列管理<em>脚本</em>和<em>模块</em>。</p>
<p>而且这个上下文可以执行<em>其它上下文</em>，或者排队<em>其它作业</em>。一个可以引发和排队的作业的例子就是<em>promise</em>。</p>
<p>当没有正在运行的执行上下文，并且执行上下文栈为空时，ECMAScript实现会从作业队列中移除第一个挂起的作业，创建一个执行上下文，并开始其执行。</p>
<blockquote>
<p><strong>注：</strong>作业队列通常是由所谓的<em>事件循环</em>来处理。ECMAScript标准并没有指定事件循环，将它留给引擎实现，不过你可以在<a href="https://gist.github.com/DmitrySoshnikov/26e54990e7df8c3ae7e6e149c87883e4">这里</a>找到一个演示示例。</p>
</blockquote>
<p>示例：</p>
<pre><code class="hljs lang-javascript firekylin-code"><ul><li><span class="line-num" data-line="1"></span><span class="hljs-comment">// 在PromiseJobs队列上入队一个新的promise。</span></li><li><span class="line-num" data-line="2"></span><span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> resolve(<span class="hljs-number">10</span>), <span class="hljs-number">0</span>))</li><li><span class="line-num" data-line="3"></span>  .then(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(value));</li><li><span class="line-num" data-line="4"></span></li><li><span class="line-num" data-line="5"></span><span class="hljs-comment">// 这个输出执行得早一些，因为它仍然是一个正在执行的上下文，</span></li><li><span class="line-num" data-line="6"></span><span class="hljs-comment">// 而作业不能先开始执行</span></li><li><span class="line-num" data-line="7"></span><span class="hljs-built_in">console</span>.log(<span class="hljs-number">20</span>);</li><li><span class="line-num" data-line="8"></span></li><li><span class="line-num" data-line="9"></span><span class="hljs-comment">// Output: 20, 10</span></li></ul><b class="name">javascript</b></code></pre><blockquote>
<p><strong>注：</strong> 更多有关promise的知识请阅读<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise">这个文档</a>。</p>
</blockquote>
<p>async函数可以等待promise，所以它们也可以排队promise作业：</p>
<pre><code class="hljs lang-javascript firekylin-code"><ul><li><span class="line-num" data-line="1"></span><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">later</span>(<span class="hljs-params"></span>) </span>{</li><li><span class="line-num" data-line="2"></span>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> <span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-number">10</span>);</li><li><span class="line-num" data-line="3"></span>}</li><li><span class="line-num" data-line="4"></span></li><li><span class="line-num" data-line="5"></span>(<span class="hljs-keyword">async</span> () =&gt; {</li><li><span class="line-num" data-line="6"></span>  <span class="hljs-keyword">let</span> data = <span class="hljs-keyword">await</span> later();</li><li><span class="line-num" data-line="7"></span>  <span class="hljs-built_in">console</span>.log(data); <span class="hljs-comment">// 10</span></li><li><span class="line-num" data-line="8"></span>})();</li><li><span class="line-num" data-line="9"></span></li><li><span class="line-num" data-line="10"></span><span class="hljs-comment">// 也会发生得早一些，因为async执行是在PromiseJobs队列中排队的。</span></li><li><span class="line-num" data-line="11"></span><span class="hljs-built_in">console</span>.log(<span class="hljs-number">20</span>);</li><li><span class="line-num" data-line="12"></span></li><li><span class="line-num" data-line="13"></span><span class="hljs-comment">// Output: 20, 10</span></li></ul><b class="name">javascript</b></code></pre><p><strong>注：</strong> 请在<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function">这里</a>阅读更多有关async函数的知识。</p>
<p>现在我们已经很接近当前JS领域的最终蓝图了。我们将看到我们所讨论过的所有这些组件的<em>主要负责人</em>：<em>代理</em>。</p>
<h2><a id="toc-fc9" class="anchor" href="#toc-fc9"></a>代理</h2>
<p>ECMScript中<em>并发</em>和<em>并行</em>是用<em>代理模式（Agent Pattern）</em>实现的。代理模式很接近于<a href="https://en.wikipedia.org/wiki/Actor_model">参与者模式（Actor Patter）</a> — 一个带有<em>消息传递</em>风格通讯的<em>轻量级进程</em>。</p>
<p><strong>定义 18：代理（Agent）：</strong>代理是封装了执行上下文栈、一组作业队列，以及代码域的一个概念。</p>
<p>依赖代理的实现可以在同一个线程上运行，也可以在单独的线程上运行。浏览器环境中的<code>Worker</code>代理就是<em>代理</em>概念的一个例子。</p>
<p>代理之间是状态相互隔离的，而且可以通过发送消息进行通讯。有些数据可以在代理之间共享，比如<code>SharedArrayBuffer</code>。代理还可以组合成<em>代理集群</em>。</p>
<p>在下例中，<code>index.html</code>调用<code>agent-smith.js</code> worker，传递共享的内存块：</p>
<pre><code class="hljs lang-javascript firekylin-code"><ul><li><span class="line-num" data-line="1"></span><span class="hljs-comment">// 在`index.html`中：</span></li><li><span class="line-num" data-line="2"></span></li><li><span class="line-num" data-line="3"></span><span class="hljs-comment">// 这个代理和其它worker之间共享的数据。</span></li><li><span class="line-num" data-line="4"></span><span class="hljs-keyword">let</span> sharedHeap = <span class="hljs-keyword">new</span> SharedArrayBuffer(<span class="hljs-number">16</span>);</li><li><span class="line-num" data-line="5"></span></li><li><span class="line-num" data-line="6"></span><span class="hljs-comment">// 我们角度的数据。</span></li><li><span class="line-num" data-line="7"></span><span class="hljs-keyword">let</span> heapArray = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Int32Array</span>(sharedHeap);</li><li><span class="line-num" data-line="8"></span></li><li><span class="line-num" data-line="9"></span><span class="hljs-comment">// 创建一个新代理（worker）。</span></li><li><span class="line-num" data-line="10"></span><span class="hljs-keyword">let</span> agentSmith = <span class="hljs-keyword">new</span> Worker(<span class="hljs-string">'agent-smith.js'</span>);</li><li><span class="line-num" data-line="11"></span></li><li><span class="line-num" data-line="12"></span>agentSmith.onmessage = <span class="hljs-function">(<span class="hljs-params">message</span>) =&gt;</span> {</li><li><span class="line-num" data-line="13"></span>  <span class="hljs-comment">// 代理发送它修改的数据的索引。</span></li><li><span class="line-num" data-line="14"></span>  <span class="hljs-keyword">let</span> modifiedIndex = message.data;</li><li><span class="line-num" data-line="15"></span></li><li><span class="line-num" data-line="16"></span>  <span class="hljs-comment">// 检查被修改的数据</span></li><li><span class="line-num" data-line="17"></span>  <span class="hljs-built_in">console</span>.log(heapArray[modifiedIndex]); <span class="hljs-comment">// 100</span></li><li><span class="line-num" data-line="18"></span>};</li><li><span class="line-num" data-line="19"></span></li><li><span class="line-num" data-line="20"></span><span class="hljs-comment">// 发送共享数据给代理</span></li><li><span class="line-num" data-line="21"></span>agentSmith.postMessage(sharedHeap);</li></ul><b class="name">javascript</b></code></pre><p>如下是worker的代码：</p>
<pre><code class="hljs lang-javascript firekylin-code"><ul><li><span class="line-num" data-line="1"></span><span class="hljs-comment">// agent-smith.js</span></li><li><span class="line-num" data-line="2"></span></li><li><span class="line-num" data-line="3"></span><span class="hljs-comment">/**</span></li><li><span class="line-num" data-line="4"></span> * 在这个worker中接受共享的 array buffer。</li><li><span class="line-num" data-line="5"></span> */</li><li><span class="line-num" data-line="6"></span>onmessage = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">message</span>) </span>{</li><li><span class="line-num" data-line="7"></span>  <span class="hljs-comment">// worker角度的共享数据。</span></li><li><span class="line-num" data-line="8"></span>  <span class="hljs-keyword">let</span> heapArray = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Int32Array</span>(message.data);</li><li><span class="line-num" data-line="9"></span></li><li><span class="line-num" data-line="10"></span>  <span class="hljs-keyword">let</span> indexToModify = <span class="hljs-number">1</span>;</li><li><span class="line-num" data-line="11"></span>  heapArray[indexToModify] = <span class="hljs-number">100</span>;</li><li><span class="line-num" data-line="12"></span></li><li><span class="line-num" data-line="13"></span>  <span class="hljs-comment">// 将索引作为消息发送回来。</span></li><li><span class="line-num" data-line="14"></span>  postMessage(indexToModify);</li><li><span class="line-num" data-line="15"></span>};</li></ul><b class="name">javascript</b></code></pre><p>上例的完整代码可以在<a href="https://gist.github.com/DmitrySoshnikov/b75a2dbcdb60b18fd9f05b595135dc82">这个gist</a>中找到。</p>
<p>所以下面是ECMAScript运行时的概述图：</p>
<p><img class="" src="http://www.xiaojichao.com/static/upload/20171215/pPyYBcy9mv_HGD2PiD6U.png" alt="alt"><noscript><img src="http://www.xiaojichao.com/static/upload/20171215/pPyYBcy9mv_HGD2PiD6U.png" alt="alt"></noscript></p>
<p>图 11. ECMAScript 运行时</p>
<p>而这就是ECMAScript引擎背后发生的事情！</p>
<p>到这里我们就结束了。这是我们可以在一篇综述文章中讲解有关JS核心的所有信息了。正如我们所提到的，js代码可以被分组到<em>模块</em>中，对象的属性可以通过<code>Proxy</code>对象进行跟踪，等等。- 我们可以在JavaScript语言的各种文档中找到很多用户级的信息。</p>
<p>这里我们试着表示一个ECMAScript程序本身的<em>逻辑结构</em>，希望它澄清了这些细节。如果你有任何疑问、建议或者反馈 - 我很乐意像以前一样在评论中讨论。</p>
<p>感谢TC-39的代表和规范的编辑帮助澄清本文。有关讨论可以在<a href="https://twitter.com/DmitrySoshnikov/status/930507793047592960">这个推特跟帖</a>中找到。</p>
<p>祝学习ECMAScript顺利！</p>
<p><strong>作者：</strong>Dmitry Soshnikov
<strong>发表于：</strong>2017年11月14日</p>

</div>
<p>本文链接：<a href="http://www.xiaojichao.com/post/jscorev2.html">http://www.xiaojichao.com/post/jscorev2.html</a></p>
<p>-- <acronym title="End of File">EOF</acronym> --</p>

<div class="post-info">
    <p>
        作者

        <a href="/author/admin" data-user="网络埋伏纪事">
            <code class="notebook">网络埋伏纪事</code>
        </a>

        发表于
        <i>2017-12-15 11:32:04</i>


        ，添加在分类

        <a href="/cate/Frontend" data-cate="前端开发">
            <code class="notebook">前端开发</code>
        </a>

        下



        ，并被添加「

        <a href="/tag/JavaScript" data-tag="JavaScript">
            <code class="notebook">JavaScript</code>
        </a>

         」标签


        ，最后修改于
        <i>2017-12-15 11:56:42</i>
    </p>

</div>
</article>`
var md = h2m(str);
console.log(md);
